#include <iostream>
#include <vector>
#include<string>
#include<algorithm>
#include<sstream>
#include<fstream>
using namespace std;
class Core
{
    public:
      int registers[32];
       int pc;
       vector<string> program;
  public:
    Core()
    {
        pc=0;
        this-> registers[32]={0};
    }
    void execute(vector<int> &memory)
    {
        string instruction = program[pc];

         stringstream ss(instruction);
        vector<string> parts;

        string part;
            while (getline(ss, part, ' ')) {
             parts.push_back(part);

         }

        string opcode = parts[0];
        if (opcode == "add") {
            int rd = stoi(parts[1].substr(1));
            int rs1 = stoi(parts[2].substr(1));
            int rs2 = stoi(parts[3].substr(1));
            registers[rd] = registers[rs1] + registers[rs2];
        } else if (opcode == "ld") {
            int rd = stoi(parts[1].substr(1));
            int location = stoi(parts[2]);
            registers[rd] = memory[location];
        }
        else if(opcode=="li")
        {
            int rd=stoi(parts[1].substr(1));
            registers[rd]=stoi(parts[2]);
        }
       else if(opcode=="addi")
       {
          int rd = stoi(parts[1].substr(1));
          int rs1 = stoi(parts[2].substr(1));
          registers[rd]=registers[rs1]+stoi(parts[3]);
       }
       else if(opcode=="lw")
       {
         int rd = stoi(parts[1].substr(1));
        string ostr=parts[2].substr(0,parts[2].find('('));
        string find=parts[2].substr(parts[2].find('x')+1);
        int offset=stoi(ostr);
        string st="";
        for(int i=0;i<find.length()-1;i++)
          {
              st+=find[i];
          }
         int addr=registers[stoi(st)];

        registers[rd] = memory[addr+offset];
       }
       else if(opcode=="sw")
       {
           int rs=stoi(parts[1].substr(1));
           string ostr=parts[2].substr(0,parts[2].find('('));
        string find=parts[2].substr(parts[2].find('x')+1);
        int offset=stoi(ostr);
        string st="";
        for(int i=0;i<find.length()-1;i++)
          {
              st+=find[i];
          }
         int addr=registers[stoi(st)];
         memory[addr+offset]=registers[rs];
       }
         else if(opcode=="slt")
         {
              int rd = stoi(parts[1].substr(1));
              int rs1 = stoi(parts[2].substr(1));
            int rs2 = stoi(parts[3].substr(1));
            if(registers[rs1]<registers[rs2])
            {
                registers[rd]=1;
            }
            else
            { 
                registers[rd]=0;
            }
         }
         else if(opcode=="bne")
         {
            int rs1 = stoi(parts[1].substr(1));
            int rs2 = stoi(parts[2].substr(1));
           string label = parts[3]; 
           if(registers[rs1]!=registers[rs2])
           {
            auto it = find(program.begin(), program.end(), label);
           if(it!=program.end())
           {
             pc=distance(program.begin(),it);
           }
             pc-=1;
           }

         }

        pc += 1;
    }
};
class Processor {
public:
    vector<int> memory;
    int clock;
    vector<Core> cores;

public:
    Processor()
    {
        memory = vector<int>(4096, 0);
       clock = 0;
       cores = vector<Core>(1);
    }
    void send(vector<string> & program,int coreval)
    {
       cores[coreval].program=program;
    }
    void run() {
        int max_pc = cores[0].program.size();
        while (clock < max_pc) {
            for (int i = 0; i < 1; ++i) {
                if (clock < cores[i].program.size()) {
                    cores[i].execute(memory);
                }
            }
            clock += 1;
        }
    }
};

int main() {
   Processor sim;
    ifstream input("assembly_code.asm");
    if (!input.is_open()) {
        cerr << "Failed to open assembly_code.asm" << endl;
        return 1;
    }

    string line;
    vector<string> asmLines;
    vector<int> values;

    bool dataSection = false;

    // Read the assembly file line by line
    while (getline(input, line)) {
        // Check if the line is not empty
        if (!line.empty()) {
            // Check if it's the start of the data section
            if (line == ".data") {
                dataSection = true;
            } else if (line == ".text") {
                // If we encounter the text section, stop reading the data section
                dataSection = false;
            } else if (dataSection) {
                // If we're in the data section
                // Check if the line contains an array declaration
                if (line.find(".word") != string::npos) {
                    // Extract array values
                    istringstream iss(line.substr(line.find(":") + 1));
                    int value;
                    while (iss >> value) {
                        values.push_back(value);
                    }
                }
            } else {
                // If we're in the text section, store the instruction line
                asmLines.push_back(line);
            }
        }
    }

    input.close();

    // Store array_values into memory starting from memory[0]
    for (size_t i = 0; i < values.size(); ++i) {
        sim.memory[i] = values[i];
    }
   

   
    input.close();

    // Store array_values into memory starting from memory[0]
    for (size_t i = 0; i < values.size(); ++i) {
        sim.memory[i] = values[i];
    }

    sim.send(asmLines, 0);
    sim.run();

    for (int i=0;i<10;i++) {
        cout << sim.memory[i] << " ";
    }
   return 0;
}

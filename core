#include <iostream>
#include <vector>
#include<string>
#include<algorithm>
#include<sstream>
#include<fstream>
#include<unordered_map>
#include<bits/stdc++.h>
using namespace std;
class Core {
public:
    unordered_map<string, int> registers; 
    //unordered_map<string, int> registers;// Map register names to indices
    int pc;
    vector<string> program;

public:
    Core() {
        // Initialize register names and indices

        for (int i = 0; i < 32; ++i) {
            registers["x" + to_string(i)] = 0;
        }
        pc = 0;
    }

    void execute(vector<int> &memory) {
        string instruction = program[pc];

        stringstream ss(instruction);
        vector<string> parts;
        string part;

        while (getline(ss, part, ' ')) {
            parts.push_back(part);
        }

        string opcode = parts[0];
        // if (opcode == "add") {
        //     string rd = parts[1];
        //     string rs1 = parts[2];
        //     string rs2 = parts[3];
            
        //     // Convert register names to indices and perform addition
        //     int rdIndex = registers[rd];
        //     int rs1Index = registers[rs1];
        //     int rs2Index = registers[rs2];
            
        //     // Perform addition
        //     memory[rdIndex] = memory[rs1Index] + memory[rs2Index];
        // } 
        //  if (opcode == "ld") {
        //     int rd = stoi(parts[1].substr(1));
        //     int location = stoi(parts[2]);
        //     registers[rd] = memory[location];
        // }
        if(opcode=="outerloop:"||opcode=="innerloop:"||opcode=="swap:"||opcode=="leave:")
        {
            
        }

        else if(opcode=="li")
        {
            string rd=parts[1];
            registers[rd]=stoi(parts[2]);
        }
       else if(opcode=="addi")
       {
          string rd = parts[1];
          string rs1 = parts[2];
          registers[rd]=registers[rs1]+stoi(parts[3]);
       }
       else if(opcode=="lw")
       {
          string rd = parts[1]; // Destination register
          string address = parts[2]; // Memory address
           size_t openBracketPos = address.find('(');
          size_t closeBracketPos = address.find(')');
          if (openBracketPos != string::npos && closeBracketPos != string::npos) {
        // Extracting the register name from the address string
        string rs = address.substr(openBracketPos + 1, closeBracketPos - openBracketPos - 1);
        // Extracting the offset from the address string
        string offsetStr = address.substr(0, openBracketPos);
        int offset = stoi(offsetStr);
        // Calculating the effective address by adding the offset to the value in the register
        int effectiveAddress = registers[rs] + offset;
        // Loading the value from memory at the effective address into the destination register
        registers[rd] = memory[effectiveAddress];
          } 
       }
       else if(opcode=="sw")
       {
           string rs = parts[1]; // Source register
            string address = parts[2]; // Memory address
          size_t openBracketPos = address.find('(');
          size_t closeBracketPos = address.find(')');
        if (openBracketPos != string::npos && closeBracketPos != string::npos) {
        // Extracting the destination register name from the address string
        string rd = address.substr(openBracketPos + 1, closeBracketPos - openBracketPos - 1);
        // Extracting the offset from the address string
        string offsetStr = address.substr(0, openBracketPos);
        int offset = stoi(offsetStr);
        // Calculating the effective address by adding the offset to the value in the register
        int effectiveAddress = registers[rd] + offset;
        // Storing the value from the source register into memory at the effective address
        memory[effectiveAddress] = registers[rs];
          }
       }
         else if(opcode=="slt")
         {
             string rd = parts[1]; // Destination register
             string rs1 = parts[2]; // Source register 1
             string rs2 = parts[3]; // Source register 2

    // Set the destination register to 1 if source register 1 < source register 2, otherwise set it to 0
            registers[rd] = (registers[rs1] < registers[rs2]) ? 1 : 0;
         }
         else if(opcode=="bne")
         {
            
             string rs1 = parts[1]; // Source register 1
             string rs2 = parts[2]; // Source register 2
            string label = parts[3]; // Label to branch to if rs1 != rs2

    // Check if the values in source registers rs1 and rs2 are not equal
           if (registers[rs1] != registers[rs2]) {
        // Find the label in the program vector
        auto it = find(program.begin(), program.end(), label);
        if (it != program.end()) {
            // Set the program counter (pc) to the distance between the beginning of the program vector and the label position
            pc = distance(program.begin(), it);
        } else {
            // Handle invalid label
            cerr << "Label not found: " << label << endl;
        }
    }
         }

        pc += 1;
    }
};
class Processor {
public:
    vector<int> memory;
    int clock;
    vector<Core> cores;

public:
    Processor()
    {
        memory = vector<int>(4096, 0);
       clock = 0;
       cores = vector<Core>(1);
    }
    void send(vector<string> & program,int coreval)
    {
       cores[coreval].program=program;
    }
    void run() {
        int max_pc = cores[0].program.size();
        while (clock < max_pc) {
            for (int i = 0; i < 1; ++i) {
                if (clock < cores[i].program.size()) {
                    cores[i].execute(memory);
                }
            }
            clock += 1;
        }
    }
};

int main() {
   Processor sim;
    ifstream input("bubblesort.asm");
    if (!input.is_open()) {
        cerr << "Failed to open bubblesort.asm" << endl;
        return 1;
    }

    string line;
    vector<string> asmLines;
    vector<int> values;

    bool dataSection = false;

    // Read the assembly file line by line
    while (getline(input, line)) {
        // Check if the line is not empty
        if (!line.empty()) {
            // Check if it's the start of the data section
            if (line == ".data") {
                dataSection = true;
            } else if (line == ".text") {
                // If we encounter the text section, stop reading the data section
                dataSection = false;
            } else if (dataSection) {
                // If we're in the data section
                // Check if the line contains an array declaration
                if (line.find(".word") != string::npos) {
                    // Extract array values
                    istringstream iss(line.substr(line.find(":") + 1));
                    int value;
                    while (iss >> value) {
                        values.push_back(value);
                    }
                }
            } else {
                if(line.find("outerloop:")){
                    asmLines.push_back("outerloop");
                }
                else if(line.find("innerloop:")){
                    asmLines.push_back("innerloop");
                }
                    else if(line.find("leave:")){
                        asmLines.push_back("leave");
                    }
                // If we're in the text section, store the instruction line
                else{
                    asmLines.push_back(line);
            }
        }
    }
    }
    input.close();

    // Store array_values into memory starting from memory[0]
    for (size_t i = 0; i < values.size(); ++i) {
        sim.memory[i] = values[i];
    }
   

   
    input.close();

    // Store array_values into memory starting from memory[0]
    for (size_t i = 0; i < values.size(); ++i) {
        sim.memory[i] = values[i];
    }

    sim.send(asmLines, 0);
    sim.run();

    for (int i=0;i<10;i++) {
        cout << sim.memory[i] << " ";
    }
   return 0;
}
